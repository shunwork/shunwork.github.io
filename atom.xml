<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ShunWorks</title>
  
  
  <link href="https://blog.shun.idv.tw/atom.xml" rel="self"/>
  
  <link href="https://blog.shun.idv.tw/"/>
  <updated>2025-12-31T04:00:00.000Z</updated>
  <id>https://blog.shun.idv.tw/</id>
  
  <author>
    <name>shun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpecKit - 從開始到放棄</title>
    <link href="https://blog.shun.idv.tw/2025/12/31/2025-12-31-speckit-from-begin-to-giveup/"/>
    <id>https://blog.shun.idv.tw/2025/12/31/2025-12-31-speckit-from-begin-to-giveup/</id>
    <published>2025-12-31T04:00:00.000Z</published>
    <updated>2025-12-31T04:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上個月上了保哥的 SDD 課程，立刻找個簡單的專案來練習。<br>先說結論：有用但不多。以下講講我的使用心得，以及推薦的使用情境。</p><h2 id="SpecKit-是什麼？"><a href="#SpecKit-是什麼？" class="headerlink" title="SpecKit 是什麼？"></a>SpecKit 是什麼？</h2><p>SpecKit 是 GitHub 推出的開發工作流程工具，想把軟體開發標準化成一套結構化流程：從建立專案憲章(Constitution)、定義需求(Specify)、規劃實作(Plan)、拆解任務(Tasks)到最後的自動化實作(Implement)。</p><h2 id="使用心得"><a href="#使用心得" class="headerlink" title="使用心得"></a>使用心得</h2><p>我在前人的商品分類小程式上實驗 SpecKit，想要將原本的同步 API 呼叫改成非同步的 batch API 呼叫。總共跑了 3 個 iteration，心得可以用下面這張圖表示：</p><p><img src="/./2025-12-31-imgs/speckit_image.png" alt="SpecKit 實測心得"></p><p>Spec 和 Plan 看起來都很完美(我真的有認真一行行 review)，但到了 Task 和 Implement 階段就會逐漸失控，出現看起來很棒實際很 shit 的東西。</p><h3 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h3><p>我認為翻車的原因主要有以下幾個：</p><p><strong>AI 的幻覺</strong><br>現今 AI 的本質都只是預測下一個 token，只是精巧地模仿著心的機能。<br>對 AI 來說，文件與規範是透過很隱含的關係影響著程式碼， AI 的產出並不是經過邏輯上嚴密的推論而來。</p><p><strong>Context 的長度有限</strong><br>基本上 AI 不會載入所有文件，所以寫在文件裡的規範不一定真的對 AI 造成效果。即使載入了也不一定獲得足夠的關注 (Attention is All You Need)。</p><p><strong>人類的幻覺</strong><br>從 spec 到規劃到實作之間存在大量的細節，通常人類覺得 AI 應該知道吧的部分 AI 並不知道。<br>btw 保哥一直說人類的幻覺比 AI 嚴重。</p><h3 id="尋找共存之道"><a href="#尋找共存之道" class="headerlink" title="尋找共存之道"></a>尋找共存之道</h3><p>經過了兩次大失敗之後，我想尋找與 AI 共存的方法。</p><p>我做了 Coding 的逆向工程：用已知的答案反推規格。</p><p>具體做法是：</p><ol><li>我先寫好程式碼</li><li>從程式碼產生 spec 後移除實作，只留下 interface</li><li>根據 spec 與 interface 進行 plan 與 task ，刪除 interface</li><li>人工審閱所有文件並微調後執行 implement</li></ol><p>這樣得到的結果大概就與我的實作有八九成像了，只需要進行一些實作細節微調。</p><p>從這個逆向工程可以得出：只要把握好 spec 與 interface，基本可以讓 AI 照著所想的規劃進行。<br>實際上這也很符合軟體工程的做法：維持介面穩定、抽換底層實作。</p><h2 id="還需要-SpecKit-嗎？"><a href="#還需要-SpecKit-嗎？" class="headerlink" title="還需要 SpecKit 嗎？"></a>還需要 SpecKit 嗎？</h2><p>回到 SpecKit ，如果我已經把 spec 和 interface 都想得很清楚了， SpecKit 是不是就毫無用武之地了。</p><p>我的答案是：是也不是。</p><p>SpecKit 仍然可以幫我釐清 spec 上的細節 (藉由 prompt 工程師精美的 prompt)，在 plan 時提供工程細節供 implement 階段參考。</p><p>只是，以上的流程並不一定要透過 SpecKit 完成，其他工具可能可以完成得更好 (<a href="https://github.com/obra/superpowers">Superpower</a> 看起來很 super)。<br>我認為 SpecKit 過於重視流程與形式，產生了一堆中間文件(review 真的很花時間)，但這些文件對開發並不一定有帶來助益。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>我之後應該不會再使用 SpecKit 來進行開發，但我透過 SpecKit 學習到了 SDD 的精神。<br>我會去找 SDD 的書籍來看 (Specification by Example 看起來不錯) ，提升與 AI 的溝通能力。<br>另外 <a href="https://github.com/Fission-AI/OpenSpec">OpenSpec</a> 看起來更輕量且彈性，也可以嘗試看看。</p>]]></content>
    
    
    <summary type="html">上個月上了保哥的 SDD 課程，立刻找個簡單的專案來練習。先說結論：有用但不多。以下講講我的使用心得，以及推薦的使用情境。</summary>
    
    
    
    <category term="軟體開發" scheme="https://blog.shun.idv.tw/categories/%E8%BB%9F%E9%AB%94%E9%96%8B%E7%99%BC/"/>
    
    
    <category term="AI" scheme="https://blog.shun.idv.tw/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>自建 RSSHub 筆記</title>
    <link href="https://blog.shun.idv.tw/2024/11/26/2024-11-26-self-host-rsshub/"/>
    <id>https://blog.shun.idv.tw/2024/11/26/2024-11-26-self-host-rsshub/</id>
    <published>2024-11-26T02:00:00.000Z</published>
    <updated>2024-11-26T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Follow 系列文第二篇，來紀錄一下我自建 RSSHub 的過程。<br>包括為什麼選擇自建、部署過程、設定 domain 的過程、以及怎麼設定 twitter 路由的設定等等。</p><h3 id="為什麼選擇自建-RSSHub？"><a href="#為什麼選擇自建-RSSHub？" class="headerlink" title="為什麼選擇自建 RSSHub？"></a>為什麼選擇自建 RSSHub？</h3><ol><li><p>穩定</p><p> 因為官方 RSSHub 節點太多人在使用了，很容易被各個網站封鎖，很容易更新不了內容。<br> 另外自建也可以設定更短的快取過期時間，更快看到新內容。</p></li><li><p>可以看社群媒體</p><p> 因為第一點的原因，官方的 RSSHub 節點基本上是爬不了社群網站的內容。<br> 還有有些路由支援使用自己的身份，例如 twitter，自建的話可以放入自己的 token。</p></li></ol><h3 id="部署到-GCP"><a href="#部署到-GCP" class="headerlink" title="部署到 GCP"></a>部署到 GCP</h3><p>GCP 在試用之外也有提供免費的額度 (參考 <a href="https://cloud.google.com/free/docs/free-cloud-features#free-tier">free-tier</a>)，如果只是簡單的應用的話不需要花到錢。</p><p>這次選擇部署在 Google Compute Engine，<br>選擇有免費額度的規格: <code>us-west1</code> 區域的 <code>E2-Micro</code> 規格，並將硬碟改成標準永久硬碟 10GB。<br>在建立 VM 時選擇直接 pull 線上的 image: <code>diygod/rsshub:latest</code>，省略還要安裝 docker 的功夫，<br>而且預設就會做好 port 的 mapping，不用另外設定。</p><p>因為 RSSHub 預設服務 port 是 <code>1200</code>，所以需要設定防火牆，<br>在 <code>VPC networks</code> 底下 <code>Firewall</code> 新增一條輸入規則 <code>tcp:1200</code>，<br>為了資安，要設定來源ip的限制，因為我選擇用 Cloudflare 做 proxy 所以只需要開放 Cloudflare 的 IP 即可 (參考 <a href="https://www.cloudflare.com/ips/">Cloudflare IP Range</a>)。<br>更嚴謹的話可以開一個新的網路並且只設定這一條規則就好。</p><p>ps. 也可以設定環境變數 <code>PORT</code> 將服務開放的 port 改成 <code>443</code></p><h3 id="設定-domain"><a href="#設定-domain" class="headerlink" title="設定 domain"></a>設定 domain</h3><p>為了減少以後還要更換 IP 的困擾，順手掛上 domain，<br>這次也請出大家的好朋友 Cloudflare，<br>在 DNS 新增一條 <code>A record</code>， proxying 到 VM 的外部 IP 上。</p><p>再來要加上 https！<br>在 <code>Rules</code> 的 <code>Origin Rules</code> 下新增一條規則，設定 <code>Custom Filter</code> 將包含指定 domain 的請求對應到 port <code>1200</code>，<br>只要 SSL 模式設成 flexible 的話 Cloudflare 就會自動幫忙處理 SSL 憑證的事，可以使用 https 開啟網頁。<br>現在使用瀏覽器開啟設定的 domain 的話就可以看到 RSSHub 的首頁了！<br>接下來就可以去 Follow 上增加 feed 了～</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="設置-twitter"><a href="#設置-twitter" class="headerlink" title="設置 twitter"></a>設置 twitter</h4><p>官方推薦設置 <code>TWITTER_AUTH_TOKEN</code>，需要使用開發者模式找到自己的 cookie 然後找到 <code>auth_token=</code> 後面那串就是了。<br>需要把它放到 VM 的環境變數，如果已經啟動 VM 了，需要重新啟動才會生效。</p><h4 id="更新版本"><a href="#更新版本" class="headerlink" title="更新版本"></a>更新版本</h4><p>因為我是直接在 VM 設定 pull image，<br>啟動時會去 pull 最新的 image ，所以只要重啟 VM 就會自動更新新的版本了。<br>(我是都點重設， IP 不會變就不用每次都去 Cloudflare 設定)</p><p>比想像中簡單就可以自建一個 RSSHub 了，祝大家順利～</p>]]></content>
    
    
    <summary type="html">Follow 系列文第二篇，來紀錄一下我自建 RSSHub 的過程。包括為什麼選擇自建、部署過程、設定 domain 的過程、以及怎麼設定 twitter 路由的設定等等。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello Follow</title>
    <link href="https://blog.shun.idv.tw/2024/10/01/2024-10-01-hello-follow/"/>
    <id>https://blog.shun.idv.tw/2024/10/01/2024-10-01-hello-follow/</id>
    <published>2024-10-01T02:00:00.000Z</published>
    <updated>2024-10-01T02:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>有幸得到 <a href="https://follow.is/">Follow</a> 的邀請碼讓我可以搶先在 alpha 階段就可以開始試用，<br>略盡棉薄之力來回饋一下分享我怎麼完成 <code>Feed Owner</code> 的任務。</p><h3 id="Follow-是什麼"><a href="#Follow-是什麼" class="headerlink" title="Follow 是什麼"></a>Follow 是什麼</h3><p>簡單的說就是一個支援多媒體播放的新一代 RSS 閱讀器。<br>搭配 <a href="https://docs.rsshub.app/">RSSHub</a> 可以將許多網站轉成 RSS 的能力，<br>將來大部分的資訊都可以匯集到這個 app 上觀看。</p><p>簡單介紹完，以下來說明我怎麼完成 <code>Feed Owner</code> 這個任務。</p><h3 id="擁有自己的-feed"><a href="#擁有自己的-feed" class="headerlink" title="擁有自己的 feed"></a>擁有自己的 feed</h3><p>首先要有一個 hexo blog，有一個 domain。<br>然後為 hexo 增加 rss 能力。</p><ol><li><p>安裝 <a href="https://github.com/hexojs/hexo-generator-feed?tab=readme-ov-file">hexo-generator-feed</a></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></li><li><p>在 <code>_config.yml</code> 增加 feed 的設定</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><code>type</code> 可選 atom 或 rss2，直接選擇現在主流的 atom 即可</li><li><code>content</code> 設定成 <code>true</code> 以便直接在 follow 可以閱讀全文</li></ul><p>Deploy 之後就可以在 <code>https://&#123;yourdomain&#125;/atom.xml</code> 看到 atom 格式的 XML。<br>然後就可以去 follow 把這個 url 加入訂閱了！</p><h3 id="認證自己的-feed"><a href="#認證自己的-feed" class="headerlink" title="認證自己的 feed"></a>認證自己的 feed</h3><ol><li>在 follow 上加入 feed 後右鍵選單選擇 <code>Claim</code></li></ol><p>這裡我用最簡單的認證方式，開一篇新文章將 follow 指定的文字貼在裡面。</p><ol start="2"><li>發表文章後回到 follow 裡將 claim 的流程走完</li></ol><p>這樣一來應該就可以解開成就拿到 100 power 發邀請碼了！<br>祝大家順利～</p>]]></content>
    
    
    <summary type="html">有幸得到 Follow 的邀請碼讓我可以搶先在 alpha 階段就可以開始試用，略盡棉薄之力來回饋一下分享我怎麼完成 Feed Owner 的任務。</summary>
    
    
    
    
  </entry>
  
</feed>
